#!/bin/bash

set -euo pipefail

SCRIPT_FILE="$(readlink -f "$0")"
SCRIPT_NAME="$(basename "${SCRIPT_FILE}")"

# Logging configuration
declare -g LOG_LEVEL="INFO"    # ERROR, WARNING, INFO, DEBUG
declare -g LOG_FORMAT="simple" # simple, level, full

# Log level priorities
declare -g -A LOG_PRIORITY=(
    ["DEBUG"]=10
    ["INFO"]=20
    ["WARNING"]=30
    ["ERROR"]=40
    ["CRITICAL"]=50
)

# Logging functions
log_color() {
    local color="$1"
    shift
    if [[ -t 2 ]]; then
        printf "\x1b[0;%sm%s\x1b[0m\n" "${color}" "$*" >&2
    else
        printf "%s\n" "$*" >&2
    fi
}

log_message() {
    local color="$1"
    local level="$2"
    shift 2

    if [[ "${LOG_PRIORITY[$level]}" -lt "${LOG_PRIORITY[$LOG_LEVEL]}" ]]; then
        return 0
    fi

    local message="$*"
    case "${LOG_FORMAT}" in
        simple)
            log_color "${color}" "${message}"
            ;;
        level)
            log_color "${color}" "[${level}] ${message}"
            ;;
        full)
            local timestamp
            timestamp="$(date -u +%Y-%m-%dT%H:%M:%S+0000)"
            log_color "${color}" "[${timestamp}][${level}] ${message}"
            ;;
        *)
            log_color "${color}" "${message}"
            ;;
    esac
}

log_error() {
    local RED=31
    log_message "${RED}" "ERROR" "$@"
}

log_info() {
    local GREEN=32
    log_message "${GREEN}" "INFO" "$@"
}

log_warning() {
    local YELLOW=33
    log_message "${YELLOW}" "WARNING" "$@"
}

log_debug() {
    local BLUE=34
    log_message "${BLUE}" "DEBUG" "$@"
}

log_critical() {
    local CYAN=36
    log_message "${CYAN}" "CRITICAL" "$@"
}

# Set log level with validation
set_log_level() {
    local level="${1^^}" # Convert to uppercase
    if [[ -n "${LOG_PRIORITY[${level}]:-}" ]]; then
        LOG_LEVEL="${level}"
    else
        log_error "Invalid log level: ${1}. Valid levels: ERROR, WARNING, INFO, DEBUG"
        exit 1
    fi
}

# Set log format with validation
set_log_format() {
    case "$1" in
        simple | level | full)
            LOG_FORMAT="$1"
            ;;
        *)
            log_error "Invalid log format: ${1}. Valid formats: simple, level, full"
            exit 1
            ;;
    esac
}

# Check if required commands are available
require_command() {
    local missing=()
    for c in "$@"; do
        if ! command -v "$c" >/dev/null 2>&1; then
            missing+=("$c")
        fi
    done

    if [[ ${#missing[@]} -gt 0 ]]; then
        log_error "Required command(s) not installed: ${missing[*]}"
        log_error "Please install the missing dependencies and try again"
        exit 1
    fi
}

# Show usage information
usage() {
    local exit_code="${1:-0}"
    cat <<EOF
USAGE:
    ${SCRIPT_NAME} [OPTIONS] git_url

    Clone git repositories into organized directory structure

    By default, the git remote name is set to the hostname from the git URL
    (e.g., 'github.com', 'gitlab.com'). Use --fork to override this behavior.

OPTIONS:
    -h, --help                Show this help message
    --log-level LEVEL         Set log level (ERROR, WARNING, INFO, DEBUG)
                              Default: INFO
    --log-format FORMAT       Set log output format (simple, level, full)
                              simple: message only
                              level:  [LEVEL] message
                              full:   [timestamp][LEVEL] message
                              Default: simple
    -f, --fork                Use 'upstream' as git remote name instead of hostname
    -t, --test                Test pre-defined git_urls

EXAMPLES:
    ${SCRIPT_NAME} https://github.com/user/repo.git
        # Remote name will be 'github.com'

    ${SCRIPT_NAME} --fork git@github.com:user/repo.git
        # Remote name will be 'upstream'

    ${SCRIPT_NAME} https://gitlab.com/group/project.git
        # Remote name will be 'gitlab.com'

    ${SCRIPT_NAME} --log-level DEBUG --test

EOF
    exit "${exit_code}"
}

# Strip git URL to extract hostname and path
strip_git_url() {
    local git_url="$1"
    if [[ -z "${git_url}" ]]; then
        log_error "Empty git URL provided"
        return 1
    fi

    echo "${git_url}" | sed -E \
        -e 's%^((https?|ssh|git):\/\/)?(git@)?([^\/:]+)[\/:]([-_.a-zA-Z0-9\/]+)$%\4/\5%' \
        -e 's%\.git$%%'
}

# Test git URL parsing with various formats
test_git_urls() {
    local -a git_urls=(
        git://github.com/user/repo.git
        http://github.com/user/repo.git
        https://github.com/user/repo.git
        git@github.com:user/repo.git
        ssh://git@github.com:user/repo.git

        git://gitlab.com/group/subgroup/project.git
        http://gitlab.com/group/subgroup/project.git
        https://gitlab.com/group/subgroup/project.git
        git@gitlab.com:group/subgroup/project.git
        ssh://git@gitlab.com:group/subgroup/project.git

        https://github.com/user/repo-with-dash.git
        https://github.com/user/repo_with_underscore.git
        https://github.com/user/repo.with.dot.git
    )

    local git_url
    for git_url in "${git_urls[@]}"; do
        printf "%-50s -> %s\n" "${git_url}" "$(strip_git_url "${git_url}")"
    done
}

# Clone or update git repository
git_clone() {
    local git_url="$1"
    if [[ -z "${git_url}" ]]; then
        log_error "Git URL is required"
        usage 1
    fi

    local relpath
    if ! relpath="$(strip_git_url "${git_url}")"; then
        log_error "Failed to parse git URL: ${git_url}"
        exit 1
    fi

    local repo_dir="${CODE_DIR}/${relpath}"
    if [[ -d "${repo_dir}/.git" ]]; then
        log_info "Repository already exists, fetching updates: ${repo_dir}"
        (
            set -x
            git --git-dir="${repo_dir}/.git" fetch --all
        )
        return
    fi

    # Determine remote name: --fork uses 'upstream', otherwise use hostname
    local git_remote
    if [[ "${USE_FORK_REMOTE}" == "true" ]]; then
        git_remote="upstream"
    else
        git_remote="${relpath%%/*}"
    fi

    log_info "Cloning repository to: ${repo_dir}"
    log_debug "Using remote name: ${git_remote}"
    (
        set -x
        git clone --origin="${git_remote}" "${git_url}" "${repo_dir}"
    )
}

# Parse command line arguments
parse_args() {
    local args
    local options="hft"
    local longoptions="help,log-level:,log-format:,fork,test"
    if ! args=$(getopt --options="${options}" --longoptions="${longoptions}" --name="${SCRIPT_NAME}" -- "$@"); then
        usage 1
    fi

    eval set -- "${args}"
    declare -g -a REST_ARGS=()

    declare -g USE_FORK_REMOTE="false"
    declare -g RUN_TEST="false"

    while true; do
        case "$1" in
            -h | --help)
                usage 0
                ;;
            --log-level)
                set_log_level "$2"
                shift 2
                ;;
            --log-format)
                set_log_format "$2"
                shift 2
                ;;
            -f | --fork)
                USE_FORK_REMOTE="true"
                shift
                ;;
            -t | --test)
                RUN_TEST="true"
                shift
                ;;
            --)
                shift
                break
                ;;
            *)
                log_error "Unexpected option: $1"
                usage 1
                ;;
        esac
    done

    # Capture remaining positional arguments
    REST_ARGS=("$@")
}

main() {
    require_command git getopt sed

    # Initialize CODE_DIR from environment or config file
    # Configuration precedence: environment variable > config file > default
    declare -g CODE_DIR="${CODE_DIR:-${HOME}/code}"
    local git_clone_env="${HOME}/.config/git/git-clone.env"
    if [[ -f "${git_clone_env}" ]]; then
        # shellcheck source=/dev/null
        source "${git_clone_env}"
    fi

    # Ensure CODE_DIR exists
    if [[ ! -d "${CODE_DIR}" ]]; then
        log_debug "Creating CODE_DIR: ${CODE_DIR}"
        mkdir -p "${CODE_DIR}"
    fi

    parse_args "$@"

    log_debug "Log level: ${LOG_LEVEL}, Log format: ${LOG_FORMAT}"
    log_debug "CODE_DIR=${CODE_DIR}"
    log_debug "USE_FORK_REMOTE=${USE_FORK_REMOTE}"

    if [[ "${RUN_TEST}" == "true" ]]; then
        test_git_urls
        exit 0
    fi

    if [[ ${#REST_ARGS[@]} -ge 1 ]]; then
        git_clone "${REST_ARGS[@]}"
    else
        log_error "Git URL is required"
        usage 1
    fi
}

main "$@"
