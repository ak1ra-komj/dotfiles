#!/usr/bin/env bash
# B9 June 2017

# mktrans
# This is similar to ImageMagick's bg_removal script, but much higher
# quality. (It's also faster and simpler to use.)
#
# For a sample, run these commands:
#    magick logo: logo.png
#    mktrans logo.png
#    magick display logo-mktrans.png

set -o errexit -o nounset -o pipefail

# Default configuration
# Fuzz is how far off the background color can be (in percent).
# This is important for getting good antialiasing.
declare -g DEFAULT_FUZZ=20
declare -g MKTRANS_SUFFIX="-mktrans"
# ImageMagick command configuration
declare -g MAGICK_CMD=""

SCRIPT_FILE="$(readlink -f "$0")"
SCRIPT_NAME="$(basename "${SCRIPT_FILE}")"

declare -g LOG_LEVEL="ERROR"   # Only show errors by default
declare -g LOG_FORMAT="simple" # simple, level, full

# Log level priorities
declare -g -A LOG_PRIORITY=(
    ["DEBUG"]=10
    ["INFO"]=20
    ["WARNING"]=30
    ["ERROR"]=40
    ["CRITICAL"]=50
)

# Logging functions
log_color() {
    local color="${1}"
    shift
    if [[ -t 2 ]]; then
        printf "\x1b[0;%sm%s\x1b[0m\n" "${color}" "${*}" >&2
    else
        printf "%s\n" "${*}" >&2
    fi
}

log_message() {
    local color="${1}"
    local level="${2}"
    shift 2

    if [[ "${LOG_PRIORITY[$level]}" -lt "${LOG_PRIORITY[$LOG_LEVEL]}" ]]; then
        return 0
    fi

    local message="${*}"
    case "${LOG_FORMAT}" in
        simple) log_color "${color}" "${message}" ;;
        level) log_color "${color}" "[${level}] ${message}" ;;
        full) log_color "${color}" "[$(date --utc --iso-8601=seconds)][${level}] ${message}" ;;
        *) log_color "${color}" "${message}" ;;
    esac
}

# shellcheck disable=SC2317
log_error() { log_message 31 "ERROR" "${@}"; }
# shellcheck disable=SC2317
log_info() { log_message 32 "INFO" "${@}"; }
# shellcheck disable=SC2317
log_warning() { log_message 33 "WARNING" "${@}"; }
# shellcheck disable=SC2317
log_debug() { log_message 34 "DEBUG" "${@}"; }
# shellcheck disable=SC2317
log_critical() { log_message 36 "CRITICAL" "${@}"; }

# Set log level with validation
set_log_level() {
    local level="${1^^}"
    if [[ -z "${LOG_PRIORITY[${level}]:-}" ]]; then
        log_error "Invalid log level: ${1}. Valid levels: ERROR, WARNING, INFO, DEBUG"
        exit 1
    fi
    LOG_LEVEL="${level}"
}

# Set log format with validation
set_log_format() {
    case "${1}" in
        simple | level | full)
            LOG_FORMAT="${1}"
            ;;
        *)
            log_error "Invalid log format: ${1}. Valid formats: simple, level, full"
            exit 1
            ;;
    esac
}

# Check if required commands are available
require_command() {
    local missing=()
    for c in "${@}"; do
        if ! command -v "${c}" >/dev/null 2>&1; then
            missing+=("${c}")
        fi
    done

    if [[ ${#missing[@]} -gt 0 ]]; then
        log_error "Required command(s) not installed: ${missing[*]}"
        log_error "Please install the missing dependencies and try again"
        exit 1
    fi
}

# Detect and configure ImageMagick command
detect_imagemagick() {
    if command -v magick >/dev/null 2>&1; then
        # WARNING: The convert command is deprecated in IMv7,
        # use "magick" instead of "convert" or "magick convert"
        MAGICK_CMD="magick"
        local version
        version=$(magick --version | head -n1)
        log_debug "Detected ImageMagick 7+: ${version}"
    elif command -v convert >/dev/null 2>&1; then
        # ImageMagick 6: use standalone 'convert'
        # Verify it's ImageMagick convert, not Windows convert.exe
        local convert_version
        if convert_version=$(convert -version 2>&1 | head -n1) && [[ "${convert_version}" == *"ImageMagick"* ]]; then
            MAGICK_CMD="convert"
            log_debug "Detected ImageMagick 6: ${convert_version}"
        else
            log_error "Found 'convert' command but it's not ImageMagick"
            log_error "Please install ImageMagick or ensure it's in your PATH"
            exit 1
        fi
    else
        log_error "ImageMagick not found. Please install ImageMagick 6 or 7"
        log_error "  - ImageMagick 7: provides 'magick' command"
        log_error "  - ImageMagick 6: provides 'convert' command"
        exit 1
    fi
}

# Show usage information
usage() {
    local exit_code="${1:-0}"
    cat <<EOF
    Convert images into shaped transparent pngs by floodfilling
    the background with transparency (antialiased alpha channel).
    Unless a different starting pixel is specified, the top left
    pixel is used as the "background" color to remove and
    floodfill starts from all four image edges.

Typical usage:
    ${SCRIPT_NAME} foo.jpg    (creates foo${MKTRANS_SUFFIX}.png)

Usage:
    ${SCRIPT_NAME} [OPTIONS] <files...>

OPTIONS:
    -h, --help                Show this help message
    --log-level LEVEL         Set log level (ERROR, WARNING, INFO, DEBUG)
                              Default: ERROR
    --log-format FORMAT       Set log output format (simple, level, full)
                              simple: message only
                              level:  [LEVEL] message
                              full:   [timestamp][LEVEL] message
                              Default: simple
    -f, --fuzz PERCENT        How loosely to match the background color
                              Default: ${DEFAULT_FUZZ}%
    -s, --speedy              Use speedy antialiasing (much faster, slightly
                              less accurate)
    -S, --suppress-antialias  Suppress antialiasing completely
                              (Useful for repeated runs)
    -p, --pixel X,Y           Floodfill from pixel at X,Y instead of 0,0

REQUIREMENTS:
    This script requires ImageMagick 6 or 7:
    - ImageMagick 7: Will use 'magick' command
    - ImageMagick 6: Will use 'convert' command

NOTES:
    * This creates an antialiased (blurred) alpha channel that is also eroded
      by half a pixel to avoid halos. Since this can be slow on large images,
      consider using the '-s' option which uses faster, lower quality antialiasing.

    * Running this script on an image that already has transparency will erode
      the image due to the antialiasing. Using -S is a workaround.

    * Finding the coordinates for -p is a pain. Consider using an image viewer
      to identify pixel coordinates.

EXAMPLES:
    ${SCRIPT_NAME} image.jpg
    ${SCRIPT_NAME} --fuzz 30 --speedy image.png
    ${SCRIPT_NAME} --pixel 10,20 --log-level INFO image.jpg
    ${SCRIPT_NAME} --log-level DEBUG --log-format full image.jpg

EOF
    exit "${exit_code}"
}

# Parse command line arguments
parse_args() {
    local args
    local options="hf:sSp:"
    local longoptions="help,log-level:,log-format:,fuzz:,speedy,suppress-antialias,pixel:"

    if ! args=$(getopt --options="${options}" --longoptions="${longoptions}" --name="${SCRIPT_NAME}" -- "${@}"); then
        usage 1
    fi

    eval set -- "${args}"

    declare -g FUZZ="${DEFAULT_FUZZ}"
    declare -g PIXEL_COMMA="0,0"
    declare -g PIXEL_PLUS="+0+0"
    declare -g SPEEDY_FLAG=""
    declare -g NO_ANTIALIAS=""
    declare -g PFLAG=""
    declare -g -a INPUT_FILES=()

    while true; do
        case "${1}" in
            -h | --help)
                usage 0
                ;;
            --log-level)
                set_log_level "${2}"
                shift 2
                ;;
            --log-format)
                set_log_format "${2}"
                shift 2
                ;;
            -f | --fuzz)
                FUZZ="${2}"
                shift 2
                ;;
            -s | --speedy)
                SPEEDY_FLAG="True"
                shift
                ;;
            -S | --suppress-antialias)
                NO_ANTIALIAS="True"
                shift
                ;;
            -p | --pixel)
                PIXEL_COMMA="${2}"
                PIXEL_PLUS="+${2%,*}+${2#*,}"
                PFLAG="True"
                shift 2
                ;;
            --)
                shift
                break
                ;;
            *)
                log_error "Unexpected option: ${1}"
                usage 1
                ;;
        esac
    done

    # Capture remaining positional arguments as input files
    INPUT_FILES=("${@}")

    if [[ ${#INPUT_FILES[@]} -eq 0 ]]; then
        log_error "No input files specified"
        usage 1
    fi
}

# Process a single image file
process_image() {
    local filename="$1"

    if [[ ! -f "${filename}" ]]; then
        log_error "File not found: ${filename}"
        return 1
    fi

    log_info "Processing: ${filename}"

    # Get color of specified pixel
    local color
    color=$(${MAGICK_CMD} "${filename}" -format "%[pixel:p{${PIXEL_COMMA}}]" info:-)

    # Handle transparent pixels
    if [[ "${color}" == *rgba*",0)" ]]; then
        color="${color%,0)},1)" # Floodfill only works with opaque colors
    fi

    if [[ "${color}" == "none" ]]; then
        log_error "${filename}: pixel at ${PIXEL_COMMA} is completely transparent. Cannot floodfill."
        return 1
    fi

    log_debug "Background color detected: ${color}"

    # Build ImageMagick command options using array
    local -a options=()

    if [[ -z "${PFLAG}" ]]; then
        # Add a 1 pixel border so we'll fill from the bottom and sides as well
        options+=(-bordercolor "${color}" -border 1)
    fi

    # In a new stack, make a copy of the image
    options+=('(' +clone)
    # [copy] floodfill with transparency ("none") starting at specified pixel
    options+=(-fuzz "${FUZZ}%" -fill none -floodfill "${PIXEL_PLUS}" "${color}")
    # [copy] extract just the transparency (alpha channel)
    options+=(-alpha extract)

    if [[ -z "${NO_ANTIALIAS}" ]]; then
        if [[ -z "${SPEEDY_FLAG}" ]]; then
            # [copy] blow up the alpha channel so we can do sub-pixel morphology
            options+=(-geometry 200%)
            # [copy] blur the alpha channel to make it antialiased
            options+=(-blur 0x0.5)
            # [copy] shrink the region that is opaque by half a pixel
            options+=(-morphology erode square:1)
            # [copy] scale the alpha channel back to normal size
            options+=(-geometry 50%)
        else # speedy antialias
            # [copy] blur the alpha channel to make it antialiased
            options+=(-blur 0x1)
            # [copy] only antialias inside the figure (<50% opacity becomes 0%)
            options+=(-level "50%,100%")
        fi
    fi

    # [copy] end the stack
    options+=(')')
    # Compose the original image and the copy's alpha channel
    options+=(-compose CopyOpacity -composite)

    if [[ -z "${PFLAG}" ]]; then
        # Remove the 1 pixel border we added
        options+=(-shave 1)
    fi

    local output_file="${filename%.*}${MKTRANS_SUFFIX}.png"

    log_debug "Command: ${MAGICK_CMD} ${filename} ${options[*]} ${output_file}"

    # shellcheck disable=SC2086
    if ${MAGICK_CMD} "${filename}" "${options[@]}" "${output_file}"; then
        log_info "Created: ${output_file}"
        return 0
    else
        log_error "Failed to process: ${filename}"
        return 1
    fi
}

main() {
    require_command getopt

    # Detect ImageMagick version and set appropriate command
    detect_imagemagick

    parse_args "$@"

    log_debug "Log level: ${LOG_LEVEL}, Log format: ${LOG_FORMAT}"
    log_debug "ImageMagick command: ${MAGICK_CMD}"
    log_debug "Configuration: FUZZ=${FUZZ}%, PIXEL=${PIXEL_COMMA}, SPEEDY=${SPEEDY_FLAG:-false}, NO_ANTIALIAS=${NO_ANTIALIAS:-false}"

    local exit_code=0
    for filename in "${INPUT_FILES[@]}"; do
        if ! process_image "${filename}"; then
            exit_code=1
        fi
    done

    exit "${exit_code}"
}

main "${@}"
